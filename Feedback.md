# Feedback

- [ ] 요구 사항(기능, 프로그래밍, 과제 진행)에 제시된 항목들을 정확히 준수한다.
- [ ] 해당 커밋의 작업 내용에 대하여 이해할 수 있도록 의미 있는 커밋 메시지를 작성한다.
- [ ] 깃으로 관리할 자원에 대하여 고려한다.
  - [ ] `node modules`는 `package.json` 파일로 설치 및 버전 관리가 가능하다.
  - [ ] IntelliJ IDEA의 `.idea`, Visual Studio Code의 `.vscode` 디렉토리는 개발 도구가 자동으로 생성한다.
- [ ] 풀 리퀘스트를 보내기 전 `main` 브랜치가 아닌 기능 구현을 위하여 새로 생성한 브랜치인지 확인한다.
- [ ] 풀 리퀘스트를 이미 열었다면 닫지 않고 수정 사항은 추가 커밋으로 자동 반영한다. 단, 미션 제출 기간 이후에는 추가 커밋을 하지 않는다.
- [ ] 좋은 변수, 함수, 클래스 이름을 짓기 위하여 노력한다.
  - [ ] 이름으로 의도를 드러낸다.
  - [ ] 이름을 축약하지 않는다.
- [ ] 공백도 코딩 컨벤션이다.
  - [ ] 의미 있는 공백 라인을 사용한다.
  - [ ] 들여쓰기에 space와 tab을 혼용하지 않는다.
- [ ] 의미 없는 주석을 달지 않는다.
- [ ] 린터(ESLint)와 코드 포매터(Prettier)의 기능을 활용한다.
  - [ ] 린터는 소스 코드에 문제가 있는지 사전에 탐색하는 작업을 돕는 소프트웨어다.
  - [ ] 코드 포매터는 개발자가 작성한 코드가 정해진 코딩 스타일을 따르도록 변환해 주는 도구다.
- [ ] 환경에 따라 개행 문자 처리가 다르게 되지 않도록 EOL(End Of Line) 설정을 확인한다.
- [ ] 불필요한 `console.log`를 남기지 않는다.
- [ ] 함수를 직접 구현하기 전에 자바스크립트에서 제공하는 API를 적극적으로 활용한다.
- [ ] 마크다운 문법을 사용하여 `README.md` 파일을 상세히 작성한다.
- [ ] 기능 목록을 재검토한다.
  - [ ] 구현 기능 목록을 정리하는 데 집중하며 너무 상세한 부분까지 작성하지 않는다.
  - [ ] 정상적인 상황뿐만 아니라 예외적인 상황도 기능 목록에 정리한다.
  - [ ] 구현 과정에서 기능 목록을 계속 업데이트한다.
- [ ] 값을 하드 코딩하지 않는다. 상수를 만들고 이름을 부여한다.
- [ ] 구현 순서도 코딩 컨벤션이다. 클래스는 필드, 생성자, 메소드 순으로 작성한다.
- [ ] 함수가 한 가지 기능만 수행하도록 만들고 이를 확인하는 기준을 세운다.
  - [ ] 여러 함수에서 중복되어 사용하는 코드가 있다면 함수 분리를 고민한다.
  - [ ] 함수 길이가 길어진다면 의식적으로 함수 분리를 연습한다.
- [ ] 자바스크립트에서 객체를 생성하는 다양한 방법을 이해하고 사용한다.
- [ ] 테스트를 작성하는 이유를 본인의 경험을 토대로 정리해 본다.
- [ ] 작은 단위 테스트부터 만든다.
  - [ ] 기능을 작게 나누고 핵심 기능부터 작게 테스트를 만든다.
- [ ] 함수 라인을 15줄로 제한하는 요구 사항을 준수한다.
  - [ ] 공백 라인도 한 라인에 해당한다.
  - [ ] 함수 라인이 15줄이 넘어 가면 함수 분리에 대하여 고민한다.
- [ ] 발생이 가능한 예외 상황들을 고려하며 프로그래밍한다.
- [ ] 비즈니스 로직과 UI 로직을 분리한다.
  - [ ] 한 클래스가 비즈니스 로직과 UI 로직을 모두 담당하지 않는다. 이는 단일 책임의 원칙에 위배된다.
- [ ] 객체의 상태 접근을 제한한다.
  - [ ] 필드에 `private(#)` 접근 제한자를 붙인다.
  - [ ] 객체의 상태를 외부에서 직접 접근하는 방식을 최소화한다.
- [ ] 객체는 객체답게 사용한다.
  - [ ] 객체에서 로직을 구현하고 메시지를 던지도록 구조를 바꾼다. 즉, `getter`를 사용하는 대신 객체에 메시지를 보낸다.
  - [ ] 상태를 가지는 객체가 직접 일하도록 만든다.
- [ ] 필드의 수를 최소화한다.
  - [ ] 필드에 중복이 존재하거나 불필요한 필드가 없는지 확인한다.
- [ ] 성공하는 케이스뿐만 아니라 예외에 대한 케이스도 테스트한다.
  - [ ] 프로그램에서 결함이 자주 발생하는 경계값을 꼼꼼히 확인한다.
- [ ] 테스트 코드도 리팩터링으로 개선한다.
  - [ ] 반복적인 수행을 중복되지 않도록 만든다.
- [ ] 테스트를 위한 코드를 기능 코드로부터 분리한다.
  - [ ] 테스트를 통과하기 위하여 기능 코드를 변경하거나 테스트에서만 사용하는 로직을 만들지 않는다.
- [ ] 단위 테스트가 어려운 코드를 리팩터링한다.
  - [ ] 단위 테스트가 어려운 코드는 클래스 내부가 아닌 외부로 분리하여 가능한 코드만 단위 테스트한다.
- [ ] 단 하나의 문장으로 핵심 기능을 정의하고 가장 먼저 구현한다.
